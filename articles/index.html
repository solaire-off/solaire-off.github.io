<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" type="image/x-icon" href="/theme/images/favicon.ico" />
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/theme/css/bulma.min.css">
  <link rel="stylesheet" href="/theme/css/style.css">

  <link type="text/plain" rel="author" href="/humans.txt" />
  <title>Заметки программиста</title>


  <link href="https://solaire-off.github.io/feeds/feed.rss" type="application/atom+xml" rel="alternate" title="solaire-off.github.io RSS Feed" />
</head>
<body>

    <section id="posts" class="section is-medium articles">
      <div class="container">
        <p class="subtitle is-5">
          <a class="bd-article-back" href="/">Об авторе</a>
        </p>
        <h3 class="title is-1">
          Заметки 
        </h3>
        <h4 class="subtitle is-4">О разработке из своего опыта и переводов</h4>
        <hr>
        <div class="columns is-desktop">
          <div class="column is-9-desktop">
            <article>
              <h2 class="title is-2">Базовая настройка Tmux</h2>
              <div class="subtitle">
                <span class="subtitle__date"> 15-03-2018</span> //
                <a class="is-visited" href="/articles/2018/03/base-tmux-settings/">Ссылка</a>
              </div>

              <div class="content is-medium">
                <p>Для запуска Tmux необходимо набрать в терминале <code>tmux</code>. </p>
<p>Команды в Tmux всегда начинаются с префикса.</p>
<pre><code>== Терминалы ==
вертикальный сплит                 prefix + %
горизонтальный сплит               prefix + "
удаление терминала                 prefix + d

== Навигация == 
вверх                              prefix + &#8593;
вниз                               prefix + &#8595;
влево                              prefix + &#8592;
вправо                             prefix + &#8594;

== Изменнеие размеров == 
вверх                              prefix + Shift + &#8593;
вниз                               prefix + Shift + &#8595;
влево                              prefix + Shift + &#8592; 
вправо                             prefix + Shift + &#8594;


== Окна ==
создать окно                       prefix + c
переименовать окно                 prefix + ,
перейти к следующему окнку         prefix + n
перекрлючение к окну по номеру     prefix + номер
удаление окна                      prefix + &


== Сессии == 
список сессей                      prefix + s
выход из сессии                    prefix + x
</code></pre>

<p>Для возврата к предыдущей сессии используется команда <code>tmux attach</code>.</p>
<p>По умолчанию <code>prefix</code> &mdash; это сочетание клавиш <code>Control + B</code>. Не самый удобный сочетание для частого использования, к тому уже является хоткеем для пользователей Emacs.</p>
<p>Для пользователей Vim советую использовать <code>Control + Space</code>, всем остальным в качестве префикса подойдет <code>Control + A</code>.</p>
<p>Для настройки Tmux в корневом каталоге создается и редактируется файл  <code>.tmux.conf</code>.</p>
<p>Установка префикса. </p>
<pre><code class="bash">set -g prefix C-Space
bind C-Space send-prefix
unbind C-b
</code></pre>

<p>Установка навигации по  hjkl.</p>
<pre><code class="bash">bind h select-pane -L 
bind j select-pane -D 
bind k select-pane -U 
bind l select-pane -R
</code></pre>

<p>Настройка этих же клавиши для регулирования размера терминала.</p>
<pre><code>bind -r H resize-pane -L 2
bind -r J resize-pane -D 2
bind -r K resize-pane -U 2
bind -r L resize-pane -R 2
</code></pre>

<p>Настройка количество строк истории, который Tmux будет хранить для истории.</p>
<pre><code>set -g history-limit 20000
</code></pre>

<p>Разрешение на использование мыши.</p>
<pre><code>setw -g mouse on
</code></pre>

<p>Нумерации окон с 1 вместо 0.</p>
<pre><code>set -g base-index 1
</code></pre>

<p>Отключение автоматического переименования окна при переходе по терминалам.</p>
<pre><code>set-option -g allow-rename off
</code></pre>

<p>Макрос на создание имени при открытие нового окна. </p>
<pre><code>bind-key c command-prompt -p &quot;window name:&quot; &quot;new-window; rename-window '%%'&quot;
</code></pre>

<p>Настройка размеров и цвета статус бара.</p>
<pre><code>set -g status-bg black
set -g status-fg white
set -g window-status-current-fg black
set -g window-status-current-attr bold
set -g status-interval 60
set -g status-left-length 30
</code></pre>

<p>Отображение имени пользователя и текущего времени в статус баре.</p>
<pre><code>set -g status-left ' #[fg=white]#(whoami) '
set -g status-right '#[fg=white]%H:%M#[default]'
</code></pre>

<p>Итоговый конфиг.</p>
<pre><code>set -g prefix C-space
bind C-space send-prefix
unbind C-b

bind h select-pane -L 
bind j select-pane -D 
bind k select-pane -U 
bind l select-pane -R

bind -r H resize-pane -L 2
bind -r J resize-pane -D 2
bind -r K resize-pane -U 2
bind -r L resize-pane -R 2


set -g history-limit 20000

setw -g mouse on


set -g base-index 1
set-option -g allow-rename off

bind-key c command-prompt -p &quot;window name:&quot; &quot;new-window; rename-window '%%'&quot;

set -g status-bg black
set -g status-fg white
set -g window-status-current-fg black
set -g window-status-current-attr bold
set -g status-interval 60
set -g status-left-length 30
set -g status-left ' #[fg=white]#(whoami) '
set -g status-right '#[fg=white]%H:%M#[default]'
</code></pre>
              </div>
              <div class="tags">
                <a href="/tmux/" class="button is-link">tmux</a>
              </div>
            </article>
            <article>
              <h2 class="title is-2">Лучший способ смены раскладки VIM</h2>
              <div class="subtitle">
                <span class="subtitle__date"> 14-02-2018</span> //
                <a class="is-visited" href="/articles/2018/02/vim-keyboard-layout-switch/">Ссылка</a>
              </div>

              <div class="content is-medium">
                <p>Первой преградой при переходе на Vim стал вопрос &mdash; как переключить раскладку, чтобы командный режим, воспринимающий хоткеи только на латинице, продолжил свою работу.</p>
<p>Эта проблема преследует всех пользователей, чей язык не использует латинский алфавит.</p>
<p>Способы решения разнятся от использования плагинов до вмешивания в системные утилиты переключения раскладки. Многие из решений страдают привязкой к определённой ОС и сложностью настройки. </p>
<p>Все они они усложняют реализацию функции, которая уже заложена в сам Vim и настраивается двумя строками в <code>vim.rc</code>.</p>
<p>Во-первых переопределяем раскладку клавиатуры:</p>
<pre><code>set keymap=russian-jcukenwin
</code></pre>

<p>Теперь переключение раскладки в режиме ввода доступно по стандартной комбинации <code>&lt;C-^&gt;</code>, что само по себе неудобно, но уже позволяет не терять время на переключении раскладки на латинский вариант после перехода в командный режим.</p>
<p>Во-вторых меняем неудобное сочетание <code>&lt;C-^&gt;</code> на более комфортное <code>&lt;C-L&gt;</code>. </p>
<pre><code>imap &lt;C-L&gt; &lt;C-^&gt;
</code></pre>

<p>В результате получается простой и кроссплатформенный способ переключения раскладки в режиме ввода, без потери функциональности в командном режиме.</p>
              </div>
              <div class="tags">
                <a href="/vim/" class="button is-link">vim</a>
              </div>
            </article>
            <article>
              <h2 class="title is-2">Как развернуть Django приложения при помощи uWSGI и Nginx на Ubuntu 14.04</h2>
              <div class="subtitle">
                <span class="subtitle__date"> 23-12-2017</span> //
                <a class="is-visited" href="/articles/2017/12/deploy-django-applications-on-ubuntu-14-04/">Ссылка</a>
              </div>

              <div class="content is-medium">
                <p>Оригинал статьи: <a href="https://www.digitalocean.com/community/tutorials/how-to-serve-django-applications-with-uwsgi-and-nginx-on-ubuntu-14-04">How To Serve Django Applications with uWSGI and Nginx on Ubuntu 14.04</a></p>
<hr />
<h2 id="_1">Введение</h2>
<p>Django - мощный веб-фреймворк который может помочь вашему Python приложению или веб-сайту сдвинуться с мертвой точки. Django включает в себя упрощенный сервер для тестирования ваше кода в пределах локальной сети, но для всего остального, например для ввода в эксплуатацию, потребуется куда более безопасный и мощный веб-сервер.</p>
<p>В этом руководстве мы продемонстрируем, как установить и настроить некоторые вещи в Ubuntu 14.04 для работы Django приложений. Мы настроим uWSGI в качестве  сервера-контейнера для совместной работы с нашими приложениями. Затем мы настроим Nginx в замен стандартному прокси-серверу в uWSGI, предоставив себе доступ к функциям по улучшению производительности и безопасности для наших приложений.</p>
<h2 id="_2">Предпосылки и цели</h2>
<p>Для прохождения этого руководство, у вас должен быть один удаленный сервер на Ubuntu 14.04 с root пользователем и настроенным <code>sudo</code>.</p>
<p>Мы будет устанавливать Django в двух разных виртуальных окружениях. Это позволит вашим проектам и их зависимостям работать раздельно друг от друга. Мы создадим два простых проекта, чтобы мы могли пройти через этапы создания многопроектой среды.</p>
<p>Как только у нас появится наше приложение, мы установим и настроим веб-сервер uWSGI. Он будет служить интерфейсом для нашего приложения, который будет транслировать клиентские запросы из HTTP-вызовов в команды Python, с которыми наше приложение сможет работать.</p>
<p>Затем мы подключим Nginx к uWSGI, чтобы воспользоваться его  высокопроизводительными механизмами обработки соединений и легко реализуемыми функциями безопасности. </p>
<p>Давайте начинать.</p>
<h2 id="virtualenv-virtualenvwrapper">Установка и настройка VirtualEnv и VirtualEnvWrapper</h2>
<p>Мы будет устанавливать наши Django проекты в их собственные виртуальные среды, чтобы изолировать их зависимости друг от друга. Для это мы установим virtualenv, который может создавать виртуальное окружение в Python, и virtualenvwrapper для более удобного работы с созданными окружениями. </p>
<p>Оба этих компонента мы будем устанавливать с помощью pip - пакетного менеджера в Python. Установить его можно из репозиториев Ubuntu:</p>
<pre><code>sudo apt-get update
sudo apt-get install python-pip
</code></pre>

<p>В этом руководстве мы будем использовать Python 2 версии. Если вы используете Python 3 версии, вы можете установить python3-pip. Затем, когда операции будут выполняться вне виртуального окружения, вам придется подставлять pip3 вместо pip в каждую команду этого руководства. </p>
<p>Теперь когда pip был установлен, мы можем установить virtualenv и virtualenvwrapper глобально, набрав:</p>
<pre><code>sudo pip install virtualenv virtualenvwrapper
</code></pre>

<p>Когда все компоненты будут установлены, мы можем настроить нашу оболочку для работы с virtualenvwrapper. Для легкой доступности все наши виртуальные окружения будут размещены в домашней директории в папке Env. Это можно настроить изменив переменную среды - WORKON_HOME.</p>
<p>Чтобы не приходилось каждый раз задавать эти переменные при создании виртуального окружения, мы может просто добавить это в наш скрипт инициализации оболочки.</p>
<p>Если вы используете Python 3 и pip3, вам также необходимо добавить еще одну строчку в скрипт инициализации среды:</p>
<pre><code>echo &quot;export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3&quot; &gt;&gt; ~/.bashrc
</code></pre>

<p>Независимо от того, какую версию Python вы используете, вам нужно запустить следующие команды:</p>
<pre><code>echo &quot;export WORKON_HOME=~/Env&quot; &gt;&gt; ~/.bashrc
echo &quot;source /usr/local/bin/virtualenvwrapper.sh&quot; &gt;&gt; ~/.bashrc
</code></pre>

<p>Теперь примените свой сценарий инициализации оболочки, чтобы вы могли использовать его в текущем сеансе:</p>
<pre><code>source ~/.bashrc
</code></pre>

<p>Сейчас у вас в домашней директории должна была появится папка <code>Env</code>, где будут хранится настройки виртуальной среды.</p>
<h2 id="django">Создание проектов на Django</h2>
<p>Теперь, когда у нас есть инструменты управления виртуальной средой, мы создадим два виртуальных окружения, установим в каждом Django и запустим два проекта.</p>
<h2 id="_3">Создание первого проекта</h2>
<p>Мы с легкостью можем создать виртуальное окружение при помощи пары команды, которые стали доступны благодаря <code>virtualenvwrapper</code>.</p>
<p>Создайте свое первое виртуальное окружение с названием вашего первого сайта или проекта:</p>
<pre><code>mkvirtualenv firstsite
</code></pre>

<p>Это создаст и активирует виртуальную среду с установленным Python и pip внутри. Чтобы показать, что вы теперь работает в своей новой виртуальной среде, ваша командная строка изменится. Это будет выглядеть примерно так: <code>(firstsite)user@hostname:~$</code>. Значение в круглых скобках - это имя вашего виртуального окружения. Любые пакеты, установленные через pip, теперь будут установлены не глобально в систему, а внутри виртуального окружения. Это позволяет изолировать зависимости каждого проекта.</p>
<p>Нашим первым шагом будет установка Django. Для этого мы можем использовать <code>pip</code> без <code>sudo</code>, так как мы устанавливаем его локально в наше виртуальное окружение.</p>
<pre><code>pip install django
</code></pre>

<p>Когда Django установлен, мы можем создать наш первый пробный проект: </p>
<pre><code>cd ~
django-admin.py startproject firstsite
</code></pre>

<p>Это создаст каталог <code>firstsite</code> в домашней директории. Внутри будет сценарий  по управлению проектом и второй каталог с тем же именем, в котором будет размещаться код проекта.</p>
<p>Перейдите в первый каталог, что мы могли начать устанавливать минимальный набор зависимостей для работы тестового проекта: </p>
<pre><code>cd ~/firstsite
</code></pre>

<p>С помощью миграции создадим базу данных SQlite, которая будет использоваться в нашем проекте. Если хотите, вы можете настроить другую базу данных для своего приложения, но это выйдет за рамки данного руководства:</p>
<pre><code>./manage.py migrate
</code></pre>

<p>Сейчас у вас в каталоге проекта должен быть файл базы данных <code>db.sqlite3</code>. Теперь мы можем создать учетную запись администратора, набрав:</p>
<pre><code>./manage.py createsuperuser
</code></pre>

<p>Вам необходимо ввести имя пользователя, электронную почту, а затем ввести и подтвердить пароль.</p>
<p>После этого откройте файл с настройками проекта при помощи текстового редактора:</p>
<pre><code>nano firstsite/settings.py
</code></pre>

<p>Так как мы будет использовать Nginx для работы нашего сайта, нам нужно указать каталог, в котором будут храниться статические файлы нашего сайта. Это позволит Nginx работать с ними напрямую, что окажет положительное влияние на производительность. Для их размещения мы укажем Django папку <code>static</code>  в корневом каталоге нашего проекта.</p>
<p>Для этого добавим следующею строку в конец файла: </p>
<pre><code>STATIC_ROOT = os.path.join(BASE_DIR, &quot;static/&quot;)
</code></pre>

<p>Когда закончите, сохраните и закройте файл. Сейчас соберем и поместим весь статический контент нашего сайта в этот каталог, набрав:</p>
<pre><code>./manage.py collectstatic
</code></pre>

<p>Чтобы подтвердить действие и собрать статический контент, введите <code>yes</code>. В каталоге проекта будет создан новый каталог  <code>static</code>.</p>
<p>После всего этого мы можем проверить наш проект, временно запустив тестовый сервер, набрав: </p>
<pre><code>./manage.py runserver 0.0.0.0:8080
</code></pre>

<p>Это запустит тестовый сервер на 8080 порту. Зайдите на ваш домен или IP-адрес вашего сервера, указав 8080 порт в браузере:</p>
<pre><code>http://server_domain_or_IP:8080
</code></pre>

<p>Вы должны увидеть страницу, которая выглядит примерно так: </p>
<figure>
  <img alt="page 'IT WORK!'" src="/images/django_uwsgi_nginx_ubuntu-14-04/sample_site.png">
  <br>
</figure>

<p>Добавив <code>/admin</code> в конец  вашего URL-адреса, вы попадете на страницу входа:</p>
<figure>
  <img alt="django login page" src="/images/django_uwsgi_nginx_ubuntu-14-04/admin_login.png">
  <br>
</figure>

<p>Зайдите на сервер, используя данные администратора, которые вы ввели командой <code>createuperuser</code>. После этого вы получите доступу к интерфейсу администратора:</p>
<figure>
  <img alt="django login page" src="/images/django_uwsgi_nginx_ubuntu-14-04/admin_interface.png">
  <br>
</figure>

<p>После проверки функция остановите тестовый сервер, нажав CTRL-C в своем терминале. Теперь мы можем перейти к нашему второму проекту.</p>
<h2 id="_4">Создание второго проекта</h2>
<p>Второй проект будет создан точно так же как и первый. В этом разделе будут краткие объяснениях, так как вы это уже проделывали.</p>
<p>Вернитесь в свой домашний каталог и создайте второе виртуальное окружения для вашего нового проекта. После активации нового окружения установите него Django:</p>
<pre><code>cd ~
mkvirtualenv secondsite
pip install django
</code></pre>

<p>Новое окружение будет создано и настроено, независимо от предыдущей виртуальной среды. Этот экземпляр Django полностью независим от предыдущего, который вы настроили ранее. Это позволит вам по мере необходимости  самим управлять и настраивать их независимо друг от друга.</p>
<p>Создайте второй проект и перейдите в его каталог:</p>
<pre><code>django-admin.py startproject secondsite
cd ~/secondsite
</code></pre>

<p>Подготовим к работе базу данных и создадим администратора: </p>
<pre><code>./manage.py migrate
./manage.py createsuperuser
</code></pre>

<p>Откроем файл с настройками:</p>
<pre><code>nano secondsite/settings.py
</code></pre>

<p>Как и в предыдущем проекте укажем папку для статических файлов:</p>
<pre><code>STATIC_ROOT = os.path.join(BASE_DIR, &quot;static/&quot;)
</code></pre>

<p>Сохраните и закройте файл. Сейчас соберите все статические файлы в заданный каталог, набрав:</p>
<pre><code>./manage.py collectstatic
</code></pre>

<p>В конце запусти тестовый сервер, чтобы проверить сайт:</p>
<pre><code>./manage.py runserver 0.0.0.0:8080
</code></pre>

<p>Вы должны поверить сайт по адресу:</p>
<pre><code>http://server_domain_or_IP:8080
</code></pre>

<p>Также зайдите в панель администратора:</p>
<pre><code>http://server_domain_or_IP:8080/admin
</code></pre>

<p>Как только проверите, что все работает должным образом, нажмите CTRL-C в своем терминале, чтобы остановить тестовый сервер.</p>
<h2 id="_5">Откат виртуальной среды</h2>
<p>Так как мы закончили часть руководства, связанную с Django, мы можем выйти из второй виртуальной среды:</p>
<pre><code>deactivate
</code></pre>

<p>Если вам снова понадобиться работать с любим из ваших сайтов на Django, вы должны повторно активировать соответствующее окружение. Это можно сделать с помощью команды <code>workon</code>:</p>
<pre><code>workon firstsite
</code></pre>

<p>Или:</p>
<pre><code>workon secondsite
</code></pre>

<p>Как только вы закончите работать над вашим сайтом, снова деактивируйте окружение:</p>
<pre><code>deactivate
</code></pre>

<h2 id="uwsgi">Настройка сервера приложений uWSGI</h2>
<p>Теперь, когда у нас есть два, установленных и готовых к работе, Django проекта, мы можем настраивать uWSGI. uWSGI - сервер приложений, который может общаться с приложениями по средствам стандартного интерфейса под названием WSGI. Чтобы узнать об этом больше, прочтите <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-uwsgi-and-nginx-to-serve-python-apps-on-ubuntu-14-04#definitions-and-concepts">этот раздел</a>  нашего руководства по установке uWSGI и Nginx на Ubuntu 14.04.</p>
<h3 id="uwsgi_1">Установка uWSGI</h3>
<p>В отличие от руководства, приведенного выше, в этом уроке мы будет устанавливать uWSGI глобально. Это создаст меньше разногласий в обслуживании нескольких проектов на Django. Прежде чем мы сможем установить uWSGI, нам нужны файлы разработки, которые будут использованы нашим программным обеспечением. Мы можем установить их прямо из репозиториев Ubuntu:</p>
<pre><code>sudo apt-get install python-dev
</code></pre>

<p>Сейчас файлы разработки доступны, и мы можем установить uWSGI глобально с помощью <code>pip</code>, набрав</p>
<pre><code>sudo pip install uwsgi
</code></pre>

<p>Мы может быстро протестировать этот сервер приложений, передав ему информацию об одном из наших сайтов. Например, мы можем указать, чтобы он работал с первым проектом, набрав:</p>
<pre><code>uwsgi --http :8080 --home /home/user/Env/firstsite --chdir /home/user/firstsite -w firstsite.wsgi
</code></pre>

<p>Здесь для работы uWSGI мы указали наше виртуальное окружение окружение, находящееся  в каталоге <code>~/Env</code>,  папку с нашим проектом и файл <code>wsgi.py</code>, хранящийся внутри каталога 'firstsite'. Для теста мы настроили работу HTTP на 8080 порту. Если вы перейдете по доменному имени или IP-адресу в вашем браузере, указав 8080 порт, вы снова увидеть свой сайт. Как только вы закончите проверять функционал, введите CTRL-C в терминале. </p>
<h2 id="_6">Создание файла конфигурации</h2>
<p>Запуск uWSGI из командной строки полезен для тестирования, но никак не для реальной работы. Для этого мы запусти uWSGI в 'Emperor mode', который позволит управлять отдельными приложениями через файлы конфигурации. </p>
<p>Создайте каталог, в которому будут ваши файлы конфигурации. Так как это глобальный процесс, создадим каталог <code>/etc/uwsgi/sites</code> для хранения наших файлов конфигурации. </p>
<p>После его создания, перейдите в каталог:</p>
<pre><code>sudo mkdir -p /etc/uwsgi/sites
cd /etc/uwsgi/sites
</code></pre>

<p>В этой папке мы разместим наши файлы конфигурации. Для каждого из проектов, с которым мы работаем, нам нужен файл конфигурации. uWSGI умеет работать с файлами конфигурации в разных форматах, но мы будем использовать <code>.ini</code> из-за их простоты.</p>
<p>Создайте файл для своего первого проект и откройте его в текстовом редакторе: </p>
<pre><code>sudo nano firstsite.ini 
</code></pre>

<p>Внутри мы должны начать с заголовка секции <code>[uWSGI]</code>. Вся наша информация будет располагаться под этим заголовком. Также мы будем использовать переменные, чтобы сделать наш файл конфигурации более удобным для повторного использования. После заголовка задайте переменную с названием <code>project</code> с именем вашего первого проекта. Затем добавьте переменную под названием <code>base</code> с указанием пути к домашнему каталогу. </p>
<pre><code>[uwsgi]
project = firstsite
base = /home/user
</code></pre>

<p>Затем мы должны настроить так настроить uWSGI, чтобы он правильно обслуживал наш проект. Для этого нам нужно добавить корневой каталог проекта, указав его в <code>chdir</code>. Мы можем комбинировать исходный каталог и имя проекта, используя синтаксис <code>%(имя_переменной)</code>, в который при чтении конфига будет подставляться значение переменной.</p>
<p>Аналогичным образом мы укажем виртуальное окружение для нашего проекта. С помощью указания модуля, мы можем точно настроить, как взаимодействовать с нашим проектом (с помощью импорта  «приложения», вызываемого из wsgi.py в каталоге нашего проекта). Эта конфигурация будет выглядеть так: </p>
<pre><code>[uwsgi]
project = firstsite
base = /home/user

chdir = %(base)/%(project)
home = %(base)/Env/%(project)
module = %(project).wsgi:application
</code></pre>

<p>Мы хотим создать <code>master</code> процесс с 5 потоками: </p>
<pre><code>[uwsgi]
project = firstsite
base = /home/user

chdir = %(base)/%(project)
home = %(base)/Env/%(project)
module = %(project).wsgi:application

master = true
processes = 5
</code></pre>

<p>После этого нам нужно указать, как uWSGI будет прослушивать подключения. В нашем тесте мы использовали сетевой порт и HTTP. Однако, раз мы собираемся использовать uWSGI в качестве обратного прокси, у нас есть варианты лучше. </p>
<p>Поскольку все компоненты работают на одном сервере, вместо сетевого порта мы может использовать UNIX-сокет. Это обеспечит лучшую производительность и более безопасно. Наш сокет не будет использовать HTTP, вместо этого он будет использовать <code>wsgi</code> - протокол uWSGI, который представляет из себя быстрый двоичный протокол, предназначенный для взаимодействия с другими серверами. Nginx нативно работает с <code>wsgi</code>, поэтому это наш лучший выбор.</p>
<p>Мы также будет изменять права сокета, чтобы предоставить веб-серверу доступ на запись. Чтобы сокет автоматически отчищался, когда служба остановлена, установим опцию <code>vacuum</code>.</p>
<pre><code>[uwsgi]
project = firstsite
base = /home/user

chdir = %(base)/%(project)
home = %(base)/Env/%(project)
module = %(project).wsgi:application

master = true
processes = 5

socket = %(base)/%(project)/%(project).sock
chmod-socket = 664
vacuum = true
</code></pre>

<p>На этом конфиг uWSGI для первого проекта завершен. Сохраните и закройте файл.</p>
<p>Преимуществом настройки файла с использованием переменных заключается в том, что это делает его невероятно удобным для повторного использования. Скопируйте файл конфигурации вашего первого проекта, чтобы использовать его в качестве основы для второго файла конфигурации.</p>
<pre><code>sudo cp /etc/uwsgi/sites/firstsite.ini /etc/uwsgi/sites/secondsite.ini
</code></pre>

<p>Откройте второй файл с помощью текстового редактора: </p>
<pre><code>udo nano /etc/uwsgi/sites/secondsite.ini
</code></pre>

<p>Чтобы наш файл заработал для второго проекта, нам необходимо изменить только одно значение. Измените переменную <code>project</code>, указав название второго проекта:</p>
<pre><code>wsgi]
project = secondsite
base = /home/user

chdir = %(base)/%(project)
home = %(base)/Env/%(project)
module = %(project).wsgi:application

master = true
processes = 5

socket = %(base)/%(project)/%(project).sock
chmod-socket = 664
vacuum = true
</code></pre>

<p>Когда закончите, сохраните и закройте файл. Ваш второй проект должен быть готов к работе.</p>
<h3 id="upstart-uwsgi">Создайте скрипт <code>Upstart</code> для uWSGI</h3>
<p>Теперь у нас есть файлы конфигурации, необходимые для обслуживания наших Django проектов, но мы все еще не автоматизировали процесс. Сейчас мы напишем сценарий для автоматического запуска uWSGI при загрузке.</p>
<p>Создадим сценарий в каталоге <code>/etc/init/uwsgi.conf</code></p>
<pre><code>sudo nano /etc/init/uwsgi.conf
</code></pre>

<p>Начните с добавления описания вашего uWSGI и указания уровней выполнения, на которых он должен запускаться. Мы установим уровни 2,3,4 и 5, так как они являются стандартными для многопользовательского режима.</p>
<pre><code>description &quot;uWSGI application server in Emperor mode&quot;

start on runlevel [2345]
stop on runlevel [!2345]
</code></pre>

<p>Далее мы должны указать группу и имя пользователя, из под которого будет происходить запуск. Так как у нас есть все необходимые файлы, запускать процесс мы будем под собственным именем пользователя. В качестве группы указываем <code>www-data</code>, под который будет работать Nginx. Наши настройки сокета из файла конфигурации uWSGI должны разрешить веб-серверу писать в сокет. Измените имя пользователя ниже, чтобы оно соответствовало вашему имени пользователя на сервере:</p>
<pre><code>description &quot;uWSGI application server in Emperor mode&quot;

start on runlevel [2345]
stop on runlevel [!2345]

setuid user
setgid www-data
</code></pre>

<p>В конце мы должны отдать команду на запуск. Нам нужно запустить uWSGI в многопользовательском режиме и указать директорию с нашими файлами конфигурации, чтобы uWSGI прочитал и обслуживал каждый из проектов.</p>
<pre><code>description &quot;uWSGI application server in Emperor mode&quot;

start on runlevel [2345]
stop on runlevel [!2345]

setuid user
setgid www-data

exec /usr/local/bin/uwsgi --emperor /etc/uwsgi/sites
</code></pre>

<p>Когда закончите, сохраните и закройте файл. Мы не будем запускать uWSGI, так как до тех пор пока мы не установим Nginx, у нас отсутствует группа <code>www-data</code>.</p>
<h2 id="nginx">Установка и настройка Nginx в качестве обратного прокси</h2>
<p>Когда uWSGI настроен и готов к работе, мы можем перейти к установке и настройки Nginx в качестве обратного прокси. Его можно скачать из стандартных репозиториев Ubuntu:</p>
<pre><code>sudo apt-get install nginx
</code></pre>

<p>После установки Nginx мы можем продолжить и создать файл конфигурации сервера  для каждого из наших проектов.</p>
<pre><code>sudo nano /etc/nginx/sites-available/firstsite
</code></pre>

<p>Внутри мы начнем описывать серверную конфигурацию с указания порта и доменного имени, на котором будет размещен наш первый проект. Предположим, у нас есть доменное имя для каждого:</p>
<pre><code>server {
    listen 80;
    server_name firstsite.com www.firstsite.com;
}

</code></pre>

<p>Далее, мы можем указать Nginx, чтобы его не волновало отсутствие favicon. Также мы укажем расположение нашего каталога статических файлов, где мы собрали статические элементы нашего сайта: </p>
<pre><code>server {
    listen 80;
    server_name firstsite.com www.firstsite.com;

    location = /favicon.ico { access_log off; log_not_found off; }
    location /static/ {
        root /home/user/firstsite;
    }
}
</code></pre>

<p>После этого мы можем использовать директиву <code>uwsgi_pass</code>, чтобы передать трафик нашему сокет файлу. Сокет файл, который мы настроили и назвали <code>firstproject.sock</code>, был расположен в корне нашего проекта. Мы будет использовать директиву <code>include</code> для включения необходимых параметров uwsgi для обработки соединения:</p>
<pre><code>server {
    listen 80;
    server_name firstsite.com www.firstsite.com;

    location = /favicon.ico { access_log off; log_not_found off; }
    location /static/ {
        root /home/sammy/firstsite;
    }

    location / {
        include         uwsgi_params;
        uwsgi_pass      unix:/run/uwsgi/firstsite.sock;
    }
}
</code></pre>

<p>На самом деле это вся конфигурация, когда закончите, сохраните и закройте файл.</p>
<p>Мы будем использовать это в качестве основы для файла конфигурации Nginx второго . Сейчас скопируйте его:</p>
<pre><code>sudo cp /etc/nginx/sites-available/firstsite /etc/nginx/sites-available/secondsite
</code></pre>

<p>Откройте новый файл в вашем текстовом редакторе:</p>
<pre><code>sudo nano /etc/nginx/sites-available/secondsite
</code></pre>

<p>Здесь вам нужно будет изменить любую ссылку на <code>firstsie</code> ссылкой на <code>secondsite.</code> Вам потребуется изменить <code>server_name</code>, чтобы ваш второй проект отвечал на запросы с другого доменного имени. Когда вы закончите, он будет выглядеть примерно так:</p>
<p>Когда вы закончите, закройте и сохраните файл.</p>
<p>Затем свяжите оба файла конфигурации с директорией <code>sites-enabled</code> в Nginx, чтобы включить их.</p>
<pre><code>sudo ln -s /etc/nginx/sites-available/firstsite /etc/nginx/sites-enabled
sudo ln -s /etc/nginx/sites-available/secondsite /etc/nginx/sites-enabled
</code></pre>

<p>Проверьте конфигурации на синтаксические ошибки, набрав:</p>
<pre><code>sudo service nginx configtest
</code></pre>

<p>Если синтаксических ошибок не обнаружено, вы можете перезапустить Nginx для загрузки новой конфигурации:</p>
<pre><code>sudo service nginx restart
</code></pre>

<p>Если вы помните заметили, мы никогда не запускали uWSGI сервер. Сделайте это, набрав:</p>
<pre><code>sudo service uwsgi start
</code></pre>

<p>Теперь вы можете перейти к двум своим проектов, использую соответствующие доменные имена. Как интерфейс пользователя, так и интерфейс администратора должны работать должным образом.</p>
<h2 id="_7">Вывод</h2>
<p>В этом руководстве мы создали два Django проекта, каждый в своей собственной виртуальной среде,  настроили uWSGI для работы с каждым проектом в независимости от другого, использую настроенную для каждого виртуальную среду. Затем мы настроили Nginx в качестве обратного прокси для обработки клиентских подключений и правильного обслуживания каждого проекта в зависимости от клиентского запроса.</p>
<p>Django упрощает создание проектов и приложений, представляя множество общих частей, что позволяет сосредоточиться на уникальных элементах. Использую цепочку инструментов  из этой стать, вы сможете легко настроить обслуживание нескольких  приложений на одном сервере.</p>
              </div>
              <div class="tags">
                <a href="/django/" class="button is-link">django</a>
                <a href="/linux/" class="button is-link">linux</a>
              </div>
            </article>
            <article>
              <h2 class="title is-2">В CSS используйте px, а не em</h2>
              <div class="subtitle">
                <span class="subtitle__date"> 13-12-2017</span> //
                <a class="is-visited" href="/articles/2017/12/in-css-use-px-not-em/">Ссылка</a>
              </div>

              <div class="content is-medium">
                <p>Автор: <a href="https://twitter.com/jgthms">Jeremy Thomas</a><br />
Оригинал статьи: <a href="http://jgthms.com/in-css-use-pixels-not-em.html">In CSS: use pixels, not em</a></p>
<hr />
<p>В CSS используются различные <a href="http://marksheet.io/css-size-units.html">единицы измерения</a>:</p>
<ul>
<li><code>px</code> пиксель</li>
<li><code>%</code> процент</li>
<li><code>em</code>  размер шрифта родительского элемента</li>
<li><code>rem</code> размер шрифта корневого элемента</li>
<li>безымянное значение (например для <code>line-height</code>)</li>
</ul>
<p>Наиболее естественной единицей измерения является пиксель, особенно для объявления высоты и ширины, так как это <strong>абсолютная</strong> единица измерения.</p>
<p>Но <strong>относительные</strong> единицы измерения, например <code>em</code>, имеют свои преимущества.</p>
<h2 id="em">Как работает em</h2>
<p><code>em</code> эквивалент  <em>текущего</em>  значения <code>font-size</code>. Так, если ваш элемент имеет <code>font-size: 12px</code>, <code>1em</code> равен <code>12px</code>.</p>
<p>С помощью объявления <code>font-size</code>, вы можете использовать <code>em</code> для определения <em>относительных</em> значений <em>различных</em> свойств:</p>
<ul>
<li><code>margin</code></li>
<li><code>padding</code></li>
<li><code>height</code></li>
<li><code>width</code></li>
<li>и т.д.</li>
</ul>
<p><code>rem</code> работает точно так же как <code>em</code>. Единственное отличие состоит в том, что <code>em</code> считает значение относительно <code>font-size</code>  <em>родительского</em> элемента, а <code>rem</code> считает <code>font-size</code> относительно  <em>корневого</em> элемента, то есть <code>&lt;html&gt;</code>.</p>
<p>C помощью изменения <em>единственного</em> значения <code>font-size</code>, вы можете изменять другие свойства:</p>
<pre><code>.button {
  font-size: 16px;
  padding: 0.75em 1em;
}
</code></pre>

<figure>
  <img alt="CSS em size button" src="/images/em-size-button.gif">
  <br>
  <figcaption>Пропорциональное изменение размера кнопки с помощью изменения размера шрифта</figcaption>
</figure>

<p>Таким образом, вы легко можете переопределять размеры кнопки, изменив только <code>font-size</code>:</p>
<pre><code>.button--small {
  font-size: 12px;
}

.button--large {
  font-size: 20px;
}
</code></pre>

<h2 id="px-em">Почему вы должны использовать px, а не em</h2>
<p>Использование <code>em</code> - весьма <strong>изящный</strong> способ для задания размеров тексту и блокам. Это позволяет сохранять каждый элемент простым и сбалансированным.</p>
<p>Я пользовался этим способом раньше. Это было больно. </p>
<h3 id="_1">Для отчетливости шрифтам необходима точность</h3>
<p>Предположим, что по умолчанию размер вашего шрифта <code>16px</code>. У вас есть <strong>заголовок</strong> размером <code>2rem</code> и <strong>подзаголовок</strong> размером <code>1.5rem</code>.</p>
<p>Потрясающе! Ваша визуальная пропорция совпадает со смысловой. Если бы вы изменили размер текста по умолчанию на <code>15px</code>, то сохранили бы эти пропорции.</p>
<p>Но <strong>не всякий размер текста подойдет каждому шрифту</strong>... Рассмотрим на следующем примере:</p>
<figure>
  <img alt="CSS fuzzy text" src="/images/em-fuzzy-text.png">
  <br>
  <figcaption>Довольно просто выставить значение в 1.25rem, но оно не будет идеальным</figcaption>
</figure>

<p>Проблема присутствует даже с большим текстом:</p>
<figure>
  <img alt="CSS fuzzy title" src="/images/em-fuzzy-title.png">
  <br>
  <figcaption>Различие в 1px имеет значение</figcaption>
</figure>

<h3 id="_2">Каждому шрифту необходим свой собственный размер</h3>
<p>Другая проблема с использованием <code>em</code> возникает, когда вы хотите сменить <strong>семейство шрифтов</strong>, потому что каждый шрифт отрисовывает размеры по-своему:</p>
<figure>
  <img alt="CSS Cabin font" src="/images/em-cabin-font.png">
  <br>
  <figcaption>12px легче вычислить, но 13px выглядят лучше</figcaption>
</figure>

<h3 id="_3">Изображением нужны пиксели</h3>
<p>Если <strong>размеры</strong> изображения установлены в пикселях, и вы хотите точно выровнять окружающий его текст по <em>вертикале</em> , то вы должны использовать <code>padding-top</code> и <code>line-height</code> в пикселях.</p>
<figure>
  <img alt="CSS image alignment" src="/images/em-image-alignment.png">
  <br>
  <figcaption>C em или rem это потребовало бы хитрых вычислений </figcaption>
</figure>

<p>(Мое лого не изображение, хоть раньше и было, но в любом случае это не важно)</p>
<h3 id="_4">Для задания границ нужны пиксели</h3>
<p>Представим, что вы хотите, чтобы ваши кнопка и поле ввода были высотой <code>38px</code>. Одинаковая высота позволит расположить элементы друг рядом с другом, например как в <a href="http://v4-alpha.getbootstrap.com/components/input-group/">Bootstrap 4</a>:</p>
<figure>
  <img alt="em input button" src="/images/em-input-button.png">
  <br>
  <figcaption>Сгруппированные и выровненные элементы</figcaption>
</figure>

<p>Как сделать это с помощью <code>rem</code>?</p>
<pre><code>.form-control {
    border: .0625rem solid #ccc;
    border-radius: .25rem;
    font-size: 1rem;
    padding: .375rem .75rem;
  }
</code></pre>

<p>Все эти вычисления основаны на размере шрифта в <code>16px</code>. Что случиться, если мы изменим значение на <code>15px</code>?</p>
<figure>
  <img alt="em input button border gone" src="/images/em-input-button-border-gone.png">
  <br>
  <figcaption>Где мои рамки??</figcaption>
</figure>

<p>Да. Теперь размер рамки установлен в <code>0.9375px</code>, и она просто исчезла, как ей и предусмотрено.</p>
<p>Вы должно быть подумали: <em>"Почему бы не использовать тени?"</em> ? Ну, <code>box-shadow</code> не является решением, так как:</p>
<ul>
<li>каждый раз, когда вы захотите добавить тень, вам нужно переопределить <em>все</em> остальные значения;</li>
<li>тень не является частью размеров блока;</li>
<li>тень может быть только одного цвета;</li>
<li>необходимо 4 тени, если вы хотите получить рамки 4 разных цветов.</li>
</ul>
<h3 id="_5">Векторным элементам необходимы пиксели</h3>
<p>Векторные элементы, например <strong>иконочные шрифты</strong>, для правильной отрисовки требуют точных значений в пикселях.</p>
<p>Стандартный размер иконок в <a href="http://fortawesome.github.io/Font-Awesome/">Font Awesome</a>  <code>28px</code>. Если вам нужны значки поменьше, остановитесь на <code>14px</code>. Любые другие значение выглядят ужасно:</p>
<figure>
  <img alt="em Font Awesome" src="/images/em-font-awesome.png">
  <br>
  <figcaption>Только кратные 7</figcaption>
</figure>

<h3 id="_6">Теперь браузеры масштабируют правильно</h3>
<p>Для увеличения размера страницы, браузеры просто <strong>увеличивают размер шрифта</strong>, делая текст больше, но сохраняя первоначальный размер блоков в пикселях. </p>
<p>Чтобы пользователи не могли сломать страницу при увеличении, необходима было задать <strong>динамичный</strong> размер блоков в <code>em</code> или <code>rem</code>.</p>
<p>Но в настоящее время браузеры могут пропорционально увеличивать  <em>любые</em> блоки. В <code>em</code> больше нет необходимости.</p>
<h2 id="_7">Просо используйте пиксели</h2>
<p>Если вы хотите правильно отрисованный интерфейс, остановитесь на пикселях:</p>
<ul>
<li>вы сможете избежать сложных <strong>вычеслений</strong> вплоть до десятитысячных  </li>
<li>вы сможете точно определять значения свойства, просто взглянув на него, ведь элемент не будет иметь <strong>зависимостей</strong></li>
<li>в любом случай <strong>препроцессоры</strong>, например Sass, позволяют использовать переменные для задания размеров и миксины для создания различный вариантов элементов</li>
<li>вы сможете <strong>выравнивать</strong> разные типы элементов, каждый из которых требует <em>свой</em> размер шрифта</li>
</ul>
<p>Вы все еще можете использовать <code>em</code> для таких вещей как межсимвольный интервал, отступы, или другие свойства так или иначе связанные с размером шрифта. Но не осталось ни одной причины, которая не устарела или не стала бесполезной, чтобы использовать их <em>везде</em>.</p>
              </div>
              <div class="tags">
                <a href="/css/" class="button is-link">css</a>
              </div>
            </article>
            <article>
              <h2 class="title is-2">Забытое искусство посещенных ссылок</h2>
              <div class="subtitle">
                <span class="subtitle__date"> 03-12-2017</span> //
                <a class="is-visited" href="/articles/2017/12/the-lost-art-of-visited-links/">Ссылка</a>
              </div>

              <div class="content is-medium">
                <p>Автор: <a href="https://twitter.com/jgthms">Jeremy Thomas</a><br />
Оригинал статьи: <a href="http://jgthms.com/the-lost-art-of-visited-links.html">The lost art of visited links</a></p>
<hr />
<p>С высокой вероятностью вы посещали <a href="https://www.google.com">эту</a> или вот <a href="https://youtube.com/">эту</a> страницу,
может были на <a href="https://news.ycombinator.com/">этой</a>, но наверняка не <a href="https://en.wikipedia.org/wiki/Driebruggen">тут</a> и 
уж точно не <a href="https://developer.mozilla.org/en/docs/Web/CSS/:visited">там</a>, но я точно уверен, что вы были <a href="/articles/2017/12/the-lost-art-of-visited-links/">здесь</a>.</p>
<p>Справедливости ради, я могу лишь <em>догадываться</em>. Хотя вы точно можете сказать, на каких страницах уже были,
даже не переходя и не наводя курсор ни на одну из этих ссылок, ведь мой сайт изменяет цвет 
<strong>посещенных</strong> ссылок.</p>
<h2 id="timelord">Путешествие во времени</h2>
<p>Навигация в интернете в основном <strong>двумерна</strong>: вы либо <em>прокручиваете</em>  (y-index), либо <em>щелкаете</em> (z-index).</p>
<p>Цвет ссылок обеспечивает третье измерение: <strong>время</strong>.</p>
<ul>
<li>
<p>Фиолетовые ссылки из <strong>прошлого</strong>.</p>
</li>
<li>
<p>Синие ссылки &mdash; кандидаты в <strong>настоящее</strong> или <strong>будущее</strong>.</p>
</li>
</ul>
<p>В зависимости от того, что вы ищете, посещенные ссылки могут вызывать
две разные реакции:</p>
<ul>
<li>
<p><em>«О, да, это тот сайт, который я искал! Я уже был там.»</em></p>
</li>
<li>
<p><em>«Я уже был на этой странице, попробую следующею.»</em></p>
</li>
</ul>
<h2 id="checklist">Ссылки как чеклист</h2>
<p><strong>Агрегаторы ссылок</strong>, такие как <a href="https://www.reddit.com/">Reddit</a> или
<a href="https://news.ycombinator.com/">Hacker News</a>, остаются одними из немногих
ресурсов, которые по-прежнему разграничивают посещенные ссылки от «новых».</p>
<p>Как правило, поисковая выдача Google поступает также. </p>
<p>Фиолетовые ссылки имеют роль <strong>выполненных задач</strong> потому что:</p>
<ul>
<li>Вы не хотите переходить на одну и туже страницу <strong>дважды</strong>.</li>
<li>Вы хотите <strong>найти</strong> список ссылок, которые вы посетили.</li>
</ul>
<p>Различие в цвете дает информацию о состоянии ссылок.</p>
<h2 id="yuck">Фиолетовые ссылки? Фу!</h2>
<p>Но почему посещенные ссылки так редко встречаются? Потому что дизайнеры
(как я) <strong>ленятся</strong> и <strong>придираются</strong> к каждой мелочи.</p>
<p>Вы хотите, чтобы по завершению макета (утвержденного вами или вашим
заказчиком) сверстанная страница на самом деле совпадала с макетом. Вам
не хочется, чтобы действия пользователя <strong>повлияли</strong> на ваш идеально
сбалансированный дизайн, не так ли?</p>
<p>Если бы вы профессионально делали дизайн кнопки X, то вы бы
проработали множество состояний (обычное, наведение, клик, фокус,
отключение), но вряд ли бы вы вспомнили про посещенную ссылку..</p>
<p>Одно из первый CSS правил, которое пишет любой дизайнер:</p>
<pre><code>a{
    color: $anythingButBlue;
}
</code></pre>
<p>Такое правило подобно сбросу цвета, повлияет на <strong>все</strong> ссылки в любом состоянии: наведения, клика,
фокуса и посещения. Вы устанавливаете его и
забываете. Вы можете использовать псевдокласс <code>:link</code>, но никто об
этом не узнает. Кроме того вы в любом случае забыли установить <code>:visited</code>.</p>
<p>Веб-страница - это живой документ: вы прорабатываете различные состояния
интерфейса в зависимости от размера экрана, пользовательского окружения и
действий пользователя.</p>
<p><strong>Игнорирование цвета посещенных ссылок походит на заботу о кросс-браузерности: полагают, что опыт использования каждого пользователя должна быть строго идентичен.</strong></p>
<h2 id="privacy">Вопрос конфиденциальности</h2>
<p>Несколько лет назад кто-то провел эксперимент: создав веб-сайт, показывающий 1000 наиболее посещаемых ссылок. В теории веб-сайт может «украсть» вашу историю браузера, вычислив цвет каждой ссылки.</p>
<p>Но в настоящее время Firefox предотвратил такое поведение:</p>
<blockquote>
<p>Даже если цвет посещенной ссылки был изменен, метод getComputedStyle всегда будет отдавать значение непосещенной ссылки.</p>
</blockquote>
<p>Как результат, стилизация посещенных ссылок весьма ограничена:</p>
<ul>
<li>
<p>Посещенные ссылки конфиденциальны. </p>
</li>
<li>
<p>Вы можете изменить лишь цвет посещенных ссылок.</p>
</li>
</ul>
<h2 id="exception">Не все ссылки одинаковы</h2>
<p>Большинство ссылок не требуют изменения цвета:</p>
<ul>
<li>Ссылки <strong>навигации</strong> (домашняя страница, учетная запись, настройки).</li>
<li>Интерактивные элементы <strong>интерфейса</strong>.</li>
</ul>
<p>Как решить, какие ссылки должны изменять цвет при посещении?</p>
<ul>
<li><strong>Внешние ссылки</strong>, поскольку они выполняют роль упоминаний (поэтому
    агрегаторы меняют цвет посещенных ссылок)</li>
<li><strong>Ссылки на статьи</strong> или любые страницы, содержание которых не
    изменяется с течением времени.</li>
</ul>
<p>Чтобы стало понятно, скажем читаете вы <a href="https://www.theguardian.com">The
Guardian</a>. Главная страница <strong>обновляется</strong> каждые несколько минут. Вам как пользователю не нужно знать, бывали ли вы здесь, потому что:</p>
<ul>
<li>Возможно вы уже находитесь на этой странице <strong>сейчас</strong>.</li>
<li>Возможно вы вернетесь сюда <strong>снова</strong>.</li>
</ul>
<p>Однако, вам бы хотелось знать, какие статьи вы уже читали, потому что их
содержание <strong>скорее всего</strong> не изменится в следующий раз, когда вы будете здесь.</p>
<p>Так, прежде чем перейти к статье, вы узнаете, видели ли её, что в зависимости от <strong>намерения</strong> определит ваше <strong>действие</strong>:</p>
<table>
<thead>
<tr>
<th>Намерение</th>
<th>Непосещенная ссылка</th>
<th>Посещенная ссылка</th>
</tr>
</thead>
<tbody>
<tr>
<td>Я хочу это увидеть</td>
<td><em>"Новая статья!"</em></td>
<td><em>"Я искал эту статью"</em></td>
</tr>
<tr>
<td>Я не хочу это видеть</td>
<td><em>"Это не выглядит интересно"</em></td>
<td><em>"Я видел это раньше, не интересно"</em></td>
</tr>
</tbody>
</table>
<p>В следующий раз, когда вы создаете сайт, подумайте о <code>:visited</code>!<br />
Пользователи скажут вам спасибо.</p>
              </div>
              <div class="tags">
                <a href="/css/" class="button is-link">css</a>
              </div>
            </article>
          </div>
			
          <div class="column  is-3 aside">
          	<div class="content is-medium">
            <h4 class="arrow">Метки</h4>
            <ul>
              <li><a href="/feeds/tags/css_feed.rss"><i class="fa fa-rss-square" aria-hidden="true"></i></a> <a href="/css/">css</a></li>
              <li><a href="/feeds/tags/django_feed.rss"><i class="fa fa-rss-square" aria-hidden="true"></i></a> <a href="/django/">django</a></li>
              <li><a href="/feeds/tags/linux_feed.rss"><i class="fa fa-rss-square" aria-hidden="true"></i></a> <a href="/linux/">linux</a></li>
              <li><a href="/feeds/tags/tmux_feed.rss"><i class="fa fa-rss-square" aria-hidden="true"></i></a> <a href="/tmux/">tmux</a></li>
              <li><a href="/feeds/tags/vim_feed.rss"><i class="fa fa-rss-square" aria-hidden="true"></i></a> <a href="/vim/">vim</a></li>
            </ul>
        	</div>
          </div>        </div>
      </div>
    </section>


  <section class="is-footer">
      <div class="container">
          <div class="content">
              <p class="has-text-grey-light has-text-centered">Генератор страниц &mdash; <a href="https://blog.getpelican.com/" rel="nofollow">Pelican Static Site Generator</a> | Хостинг <a href="https://pages.github.com/" rel="nofollow">Github Pages</a> | Тема сверстана с помощью <a href="http://bulma.io/" rel="nofollow">Bulma</a> <br/> Для получения новый статей подпишитесь по  <a href="https://solaire-off.github.io/feeds/feed.rss">RSS</a>.</p>
          </div>
      </div>
  </section>

<link rel="stylesheet" href="/theme/css/default.css">
<script src="/theme/js/highlight.pack.js"></script>
<script>hljs.initHighlighting();</script>


</body>
</html>